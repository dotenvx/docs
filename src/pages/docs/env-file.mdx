export const description = 
  'The .env file separates your secrets from code.'

##### [dotenvx](/docs)
# .env

The `.env` file separates your secrets from code. Here is what it looks like.

```ini {{ title: '.env' }}
# .env
STRIPE_API_KEY=scr_12345
TWILIO_API_KEY=abcd1234
```

It's a simple format – key/value separated by an equal sign. You can additionally include comments.

Then it is loaded into your application code using `process.env`.

<CodeGroup>

```js {{ title: 'Node' }}
console.log('Hello ' + process.env.HELLO)
```

```python {{ title: 'Python' }}
import os
print("Hello " + os.getenv("HELLO", ""))
```

```php {{ title: 'PHP' }}
<?php echo "Hello {$_SERVER["HELLO"]}\n";
```

```ruby {{ title: 'Ruby' }}
puts "Hello #{ENV["HELLO"]}"
```

```go {{ title: 'Go' }}
package main
import "fmt"
import "os"
func main() {
  fmt.Printf("Hello %s\n", os.Getenv("HELLO"))
}
```

```rust {{ title: 'Rust' }}
fn main() {
  let hello = std::env::var("HELLO").unwrap_or("".to_string());
  println!("Hello {hello}");
}
```

</CodeGroup>

This way your secrets – like your Stripe API key – are not commited to your code.

By separating your secrets from your code (your `.env` file is not commited to source control), you improve your security posture. If your code leaks, your secrets (like your Stripe API key) are less likely to be at risk.

## History

The `.env` file format was [introduced by Heroku in 2012](https://12factor.net/config) and popularized by the [dotenv node](https://www.npmjs.com/package/dotenv) and [dotenv ruby](https://github.com/bkeepers/dotenv) libraries in 2013.

> Apps sometimes store config as constants in the code. This is a violation of twelve-factor, which requires strict separation of config from code. Config varies substantially across deploys, code does not.
> 
> A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials.
> [The Twelve-Factor App](https://12factor.net/config)

Other languages, frameworks, platforms, and infra tools like Docker followed soon after – implementing environment variable support. Today, it has become an industry standard.
