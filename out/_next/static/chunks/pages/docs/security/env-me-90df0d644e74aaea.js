(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1917],{2593:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/security/env-me",function(){return n(1698)}])},1698:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return a}});var i=n(5893),o=n(1151);function r(e){let t=Object.assign({h5:"h5",a:"a",h1:"h1",p:"p",h2:"h2",pre:"pre",code:"code"},(0,o.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h5,{children:(0,i.jsx)(t.a,{href:"/docs/security",children:"Security"})}),"\n",(0,i.jsx)(t.h1,{children:".env.me"}),"\n",(0,i.jsx)(t.p,{children:"The .env.me file uniquely authorizes you to access a project's shared .env file. You can think of it like your unique SSH key at GitHub."}),"\n",(0,i.jsx)(t.p,{children:"But the .env.me credential has stricter security measures than GitHub's SSH key. The GitHub SSH key allows FULL access to all your repositories. We think this is too dangerous. So we have limited the authorization scope."}),"\n",(0,i.jsx)(t.p,{children:"The .env.me credential authorizes your machine against a single project. In other words, for each unique project on your machine you will have a unique .env.me credential file. These are generated via the cli (and in some cases the ui) and through a proven authentication method - minimizing the complexity of managing multiple credentials."}),"\n",(0,i.jsx)(t.p,{children:"This is all by design. This way if an attacker somehow gets access to your .env.me credential (maybe you accidently committed it to source control), they are not getting access to all your secrets. You can then rotate your .env.me credential for that project only, manually rotate or auto-rotate (coming soon) that project's secrets, and be on your way. As a CTO, CSO, or startup founder this helps you mitigate the fallout from a security leak - setting you apart from others. In fact, your security hygiene will be better than most banks and fortune 500 companies in this regard."}),"\n",(0,i.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.p,{children:"Here's an example of what a .env.me file looks like:"}),"\n",(0,i.jsx)(t.pre,{code:"DOTENV_ME=me_b1831e4…\n",children:(0,i.jsx)(t.code,{children:"DOTENV_ME=me_b1831e4…\n"})}),"\n",(0,i.jsx)(t.p,{children:"The first thing you might notice is the formatting is the same as a .env file. This is intentional to allow for maximum future interoperability - just like the .env.vault file."}),"\n",(0,i.jsx)(t.p,{children:"The DOTENV_ME key will be the only value this file contains. Keep it safe and out of source control - just like your .env file."}),"\n",(0,i.jsx)(t.h2,{id:"generating",children:"Generating"}),"\n",(0,i.jsxs)(t.p,{children:["You can generate a .env.me file at ",(0,i.jsx)(t.a,{href:"https://vault.dotenv.org/ui/ui1/project/new",children:"vault.dotenv.org"})," or using ",(0,i.jsx)(t.a,{href:"https://github.com/dotenv-org/dotenv-vault",children:"dotenv-vault"}),". The authorization flow follows a similar pattern to world class authorization flows found in cli tools like ",(0,i.jsx)(t.a,{href:"https://devcenter.heroku.com/articles/heroku-cli",children:"Heroku's cli"})," and ",(0,i.jsx)(t.a,{href:"https://vercel.com/cli",children:"Vercel's cli"}),". It is both secure and simple."]})]})}var a=!0;t.default=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(r,e)})):r(e)}}},function(e){e.O(0,[9774,2888,179],function(){return e(e.s=2593)}),_N_E=e.O()}]);